# 利用R語言進行監督式機器學習 {#supervised_machine_learning}

## 課程簡介 {-}

### 課程簡介 {-}


### 學習目標 {-}

```{r results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
```

[TMDB 5000 Movie Dataset](https://www.kaggle.com/tmdb/tmdb-movie-metadata/downloads/tmdb-5000-movie-dataset.zip/2)
```{r message=FALSE, warning=FALSE}
movies <- read_csv("tmdb_5000_movies.csv")
```

```{r}
summary(movies)
```

[Project Report: IMDB 5000 Movie Dataset] (http://rstudio-pubs-static.s3.amazonaws.com/342210_7c8d57cfdd784cf58dc077d3eb7a2ca3.html#problem-statement)

## 資料整理
整理各個variable，分為以下四類

1. id
2. 與本次分析無關者：homepage, keywords, original_title, overview, production_countries, spoken_languages, status, tagline, title
3. 數值資料類型：budget, popularity, revenue, runtime, vote_average, vote_count
4. 日期資料類型：release_date
5. 簡單字串資料類型：original_language
6. 複雜字串資料類型：genres, production_companies

### 與本次分析無關者

與本次分析無關的variable，不需進一步分析，可以捨棄。

```{r}
movies <- movies %>%
  select(-homepage, -keywords, -original_title, -overview, -production_countries, -spoken_languages, -status, -tagline, -title)
```

從20個variables，轉換為11個variables

### 數值資料類型

觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

`budget`(預算)、`revenue`(收入)、`runtime`(放映時間)、`vote_count`(投票人數)等為0並不合理，首先刪除這些資料為0者
```{r}
movies <- movies %>%
  filter(budget>0 & revenue>0 & runtime>0 & vote_count>0)
```

再觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

`budget`最小為1 ，看起來仍然不合理。顯示`budget`少於1000的電影共幾筆？
```{r}
print(paste("budget少於1000的電影數量：", nrow(movies[movies$budget<1000,])))
```

刪除`budget`少於1000的電影
```{r}
movies <- movies %>%
  filter(budget>=1000)
```

收入太少，也不正常，顯示`revenue`少於1000的電影共幾筆？
```{r}
print(paste("revenue少於1000的電影數量：", nrow(movies[movies$revenue<1000,])))
```

再刪除`revenue`少於1000的電影
```{r}
movies <- movies %>%
  filter(revenue>=1000)
```

分析`runtime`的分布情形
```{r}
summary(movies$runtime)
```
似乎OK.

分析`vote_average`
```{r}
summary(movies$vote_average)
```
也還可以。

最後分析`vote_count`，投票人數太少，資料較不準確，顯示`vote_count`少於100的電影共幾筆？
```{r}
print(paste("vote_count少於100的電影數量：", nrow(movies[movies$vote_count<100,])))
```

再刪除`vote_count`少於100的電影
```{r}
movies <- movies %>%
  filter(vote_count>=100)
```

再觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

### 日期資料類型
分析`release_date`，因為其資料型態是`Date`，所以載入日期時間處理套件
```{r results='hide', message=FALSE, warning=FALSE}
library(lubridate)
```

觀察`release_date`的分布情形
```{r}
summary(movies$release_date)
```
從1927年到2016年，最早期的電影數較少

查看每年的上映電影數
```{r}
movies %>%
  mutate(release_year=year(release_date)) %>%
  group_by(release_year) %>%
  summarise(count=n()) %>%
  ggplot() +
  geom_line(aes(x=release_year, y=count)) +
  scale_x_continuous(limits=c(1910, 2020), breaks=seq(1910, 2020, 10)) +
  labs(x="放映年份", y="電影數量") +
  theme(panel.background = element_blank(),
        panel.grid.major.y = element_line(color="grey70"),
        axis.line = element_line(color="grey"))
```

以放映年份取代放映日期，便於之後的分析
```{r}
movies <- movies %>%
  mutate(release_year=year(release_date)) %>%
  select(-release_date)
```

### 簡單字串類型
簡單字串資料類型與複雜資料的差別是前者的資料格式較單純，簡單字串資料類型只有一個variable：`original_language`。

分析`original_language`
```{r}
movies %>%
  group_by(original_language) %>%
  summarise(count=n()) %>%
  mutate(proportion=count/sum(count)) %>%
  arrange(desc(proportion))
```

可以發現雖然`original_language`中有許多可能的值，也就是收錄許多語言的電影，但絕大部分是英語片(96.64%)，因此捨棄這個variable
```{r}
movies <- movies %>%
  select(-original_language)
```

### 複雜字串資料類型
IMDB 5000 Movie Dataset中，為了可以表示多個可能的值，`genres`(電影類型)和`production_companies`製作公司都是屬於較複雜的字串資料類型，而且都是以JSON的方式表示這些值。例如

```{r}
movies$genres[1]
```

因此，為了表示這些值，首先載入JSON的處理套件`jsonlite`。
```{r results='hide', message=FALSE, warning=FALSE}
library(jsonlite)
```

並且撰寫一個函數來取得這些variable上所有的資料
```{r}
valueExtract <- function (y) {
  x<- fromJSON(y)
  g <- paste(x$name, collapse="%")
  gsub(" ", "_", g)
}
```

首先處理所有電影的genres資料
```{r}
movies$genres_data <- sapply(movies$genres, valueExtract)
```

將電影的每一個genre展開
```{r}
movies_genres <- movies %>%
  select(id, genres_data) %>%
  mutate(genres_data=strsplit(genres_data, split="%")) %>%
  unnest(genres_data) %>%
  mutate(value=1)
```

統計每一個genre出現的電影數，並繪製成圖形
```{r}
movies_genres %>%
  group_by(genres_data) %>%
  summarise(count=sum(value)) %>%
  ggplot() +
  geom_col(aes(x=reorder(genres_data, count), y=count)) +
  coord_flip() +
  scale_y_continuous(limits=c(0, 1800), breaks=seq(0, 1800, 300)) +
  labs(x="類型", y="電影數") +
  theme(panel.background = element_blank(),
        panel.grid.major.x = element_line(color="grey"),
        axis.line =  element_line(color="grey"))
```
最多為Drama、Comedy、Thriller和Action，最少者如Western和Documentary。


將movies_genres從long format轉成wide format
```{r}
movies_genres <- movies_genres %>%
  mutate(genres_data=paste0("g_", genres_data)) %>%
  spread(key=genres_data, value=value, fill=0)
```

合併兩個data frame，捨棄genres和genres_data兩個variables
```{r}
movies <- movies %>%
  left_join(movies_genres) %>%
  select(-genres, -genres_data)
```

分析`production_companies`
```{r}
movies$pc_data <- sapply(movies$production_companies, valueExtract)
```

將電影的每一個`production_companies`展開
```{r}
movies_pc <- movies %>%
  select(id, pc_data) %>%
  mutate(pc_data=strsplit(pc_data, split="%")) %>%
  unnest(pc_data) %>%
  mutate(value=1)
```

統計電影製作公司與他們製作的電影數 (按電影數排名)
```{r}
production_companies <- movies_pc %>%
  group_by(pc_data) %>%
  summarise(count=n()) %>%
  arrange(desc(count))
```

製作電影數前100的電影製作公司
```{r}
top100pc <- production_companies %>%
  slice(1:100) %>%
  pull(pc_data)
```

電影的製作公司包含幾家前100製作公司
```{r}
movies_pc <- movies_pc %>%
  mutate(value=ifelse(pc_data %in% top100pc, 1, 0)) %>%
  group_by(id) %>%
  summarise(top_pc_number=sum(value))
```

將電影的製作公司包含前100製作公司的數量與movies合併，捨棄production_companies和pc_data兩個variables，並且將top_pc_number的`NA`值改為0。
```{r}
movies <- movies %>%
  left_join(movies_pc) %>%
  select(-production_companies, -pc_data) %>%
  mutate(top_pc_number=ifelse(is.na(top_pc_number), 0, top_pc_number))
```

### 準備預測目標

預測的目標variable為`vote_average`
```{r}
movies %>%
  ggplot() +
  geom_histogram(aes(x=vote_average), breaks=seq(0, 10, 1)) +
  scale_x_continuous(breaks=seq(0, 10, 1), minor_breaks = NULL) +
  labs(x="vote_average區間", y="電影數量") +
  theme(panel.background = element_blank(),
        axis.line=element_line(color="grey"),
        panel.grid.major.y = element_line(color="grey90"))
```

將`vote_average`分為x<=5, 5<x<=6, 6<x<=7以及7<x等四個區間

```{r}
movies <- movies %>%
  mutate(vote_average_p=cut(vote_average, breaks=c(0, 5, 6, 7, 10)))
```

檢視資料區間結果
```{r}
movies %>%
  select(vote_average, vote_average_p) %>%
  slice(1:10)
```

### 完成資料整理

在進行資料探勘前，最後再檢視一次movies
```{r}
summary(movies)
```

### 切分訓練與測試資料

```{r results='hide', message=FALSE, warning=FALSE}
library(caret)
```

```{r}
sd <- round(second(Sys.time())*100)

set.seed(sd)

# Step 1: Get row numbers for the training data
trainRowNumbers <- createDataPartition(movies$vote_average_p, p=0.8, list=FALSE)

# Step 2: Create the training  dataset
train_set <- movies[trainRowNumbers,]

# Step 3: Create the test dataset
test_set <- movies[-trainRowNumbers,]
```


## 進行分類樹監督式學習

載入分類樹及相關繪圖套件
```{r results='hide', message=FALSE, warning=FALSE}
library(rpart)
library(rpart.plot)
```

利用train_set的資料訓練分類樹
```{r}
class.tree <- rpart(vote_average_p ~ . -vote_average -id,
                    data = train_set, method = "class",
                    minsplit=30, cp=0.00001, xval=5)
```

```{r}
printcp(class.tree)
```

```{r}
min(class.tree$cptable[, "xerror"])
```

```{r}
which.min(class.tree$cptable[, "xerror"])
```

```{r}
class.tree$cptable[which.min(class.tree$cptable[, "xerror"]), "CP"]
```

```{r}
pruned.tree <- prune(class.tree,
                     cp = class.tree$cptable[which.min(class.tree$cptable[,"xerror"]),"CP"])
```

```{r}
train_res <- predict(pruned.tree, train_set, type = "class")
```


```{r}
confusionMatrix(train_res, train_set$vote_average_p)
```

```{r}
test_res <- predict(pruned.tree, test_set, type = "class")
```

```{r}
confusionMatrix(test_res, test_set$vote_average_p)
```

## 進行隨機森林監督式學習

載入隨機森林套件
```{r}
library(randomForest)
```

```{r}
rf <- randomForest(vote_average_p ~ . -vote_average -id, data = train_set)
```

```{r}
importance <- importance(rf)
data.frame(variable=dimnames(importance)[[1]],
           MeanDecreaseGini=importance,
           stringsAsFactors = FALSE) %>%
  arrange(desc(MeanDecreaseGini)) %>%
  slice(1:10) %>%
  ggplot() +
  geom_col(aes(x=reorder(variable, MeanDecreaseGini), y=MeanDecreaseGini)) +
  coord_flip()
```

```{r}
rf_res <- predict(rf, test_set)
```

```{r}
confusionMatrix(rf_res, test_set$vote_average_p)
```


