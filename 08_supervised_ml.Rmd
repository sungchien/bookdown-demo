# 利用R語言進行監督式機器學習 {#supervised_machine_learning}

## 課程簡介 {-}

### 課程簡介 {-}


### 學習目標 {-}

```{r results='hide', message=FALSE, warning=FALSE}
library(tidyverse)
```

[TMDB 5000 Movie Dataset](https://www.kaggle.com/tmdb/tmdb-movie-metadata/downloads/tmdb-5000-movie-dataset.zip/2)
```{r message=FALSE, warning=FALSE}
movies <- read_csv("tmdb_5000_movies.csv")
```

```{r}
summary(movies)
```

[Project Report: IMDB 5000 Movie Dataset] (http://rstudio-pubs-static.s3.amazonaws.com/342210_7c8d57cfdd784cf58dc077d3eb7a2ca3.html#problem-statement)

## 資料整理
整理各個variable，分為以下四類

1. id
2. 與本次分析無關者：homepage, original_title, overview, production_countries, spoken_languages, status, tagline, title
3. 數值資料類型：budget, popularity, revenue, runtime, vote_average, vote_count
4. 日期資料類型：release_date
5. 簡單字串資料類型：original_language
6. 複雜字串資料類型：genres, keywords, production_companies

### 與本次分析無關者

與本次分析無關的variable，不需進一步分析，可以捨棄。

```{r}
movies <- movies %>%
  select(-homepage, -original_title, -overview, -production_countries, -spoken_languages, -status, -tagline, -title)
```

從20個variables，轉換為12個variables

### 數值資料類型

觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

`budget`(預算)、`revenue`(收入)、`runtime`(放映時間)、`vote_count`(投票人數)等為0並不合理，首先刪除這些資料為0者
```{r}
movies <- movies %>%
  filter(budget>0 & revenue>0 & runtime>0 & vote_count>0)
```

再觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

`budget`最小為1 ，看起來仍然不合理。顯示`budget`少於1000的電影共幾筆？
```{r}
print(paste("budget少於1000的電影數量：", nrow(movies[movies$budget<1000,])))
```

刪除`budget`少於1000的電影
```{r}
movies <- movies %>%
  filter(budget>=1000)
```

收入太少，也不正常，顯示`revenue`少於1000的電影共幾筆？
```{r}
print(paste("revenue少於1000的電影數量：", nrow(movies[movies$revenue<1000,])))
```

再刪除`revenue`少於1000的電影
```{r}
movies <- movies %>%
  filter(revenue>=1000)
```

分析`runtime`的分布情形
```{r}
summary(movies$runtime)
```
似乎OK.

分析`vote_average`
```{r}
summary(movies$vote_average)
```
也還可以。

最後分析`vote_count`，投票人數太少，資料較不準確，顯示`vote_count`少於100的電影共幾筆？
```{r}
print(paste("vote_count少於100的電影數量：", nrow(movies[movies$vote_count<100,])))
```

再刪除`vote_count`少於100的電影
```{r}
movies <- movies %>%
  filter(vote_count>=100)
```

再觀察每個數值資料的範圍
```{r}
movies %>%
  select(budget, popularity, revenue, runtime, vote_average, vote_count) %>%
  summary()
```

### 日期資料類型
分析`release_date`，因為其資料型態是`Date`，所以載入日期時間處理套件
```{r  results='hide', message=FALSE, warning=FALSE}
library(lubridate)
```

觀察`release_date`的分布情形
```{r}
summary(movies$release_date)
```
從1927年到2016年，最早期的電影數較少

查看每年的上映電影數
```{r}
movies %>%
  mutate(release_year=year(release_date)) %>%
  group_by(release_year) %>%
  summarise(count=n()) %>%
  ggplot() +
  geom_line(aes(x=release_year, y=count)) +
  scale_x_continuous(limits=c(1910, 2020), breaks=seq(1910, 2020, 10)) +
  labs(x="放映年份", y="電影數量") +
  theme(panel.background = element_blank(),
        panel.grid.major.y = element_line(color="grey70"),
        axis.line = element_line(color="grey"))
```

以放映年份取代放映日期，便於之後的分析
```{r}
movies <- movies %>%
  mutate(release_year=year(release_date)) %>%
  select(-release_date)
```

### 簡單字串類型
簡單字串資料類型與複雜資料的差別是前者的資料格式較單純，簡單字串資料類型只有一個variable：`original_language`。

分析`original_language`
```{r}
movies %>%
  group_by(original_language) %>%
  summarise(count=n()) %>%
  mutate(proportion=count/sum(count)) %>%
  arrange(desc(proportion))
```

可以發現雖然`original_language`中有許多可能的值，也就是收錄許多語言的電影，但絕大部分是英語片(96.64%)，因此將這個variable轉成是否為英語片(is_en)
```{r}
movies <- movies %>%
  mutate(is_en=ifelse(original_language=="en", 1, 0)) %>%
  select(-original_language)
```

### 複雜字串資料類型
接著分析genres，有多少電影的genres為空白(blank)
```{r}
print(paste("genres為空白的電影數量：", nrow(movies[movies$genres=="",])))
```

查看前五筆電影的genres資料
```{r}
movies$genres[1:5]
```

每一筆電影的genres資料都是JSON格式

載入處理JSON的套件
```{r}
library(jsonlite)
```

讀取第一筆電影的genres資料
```{r}
fromJSON(movies$genres[1])
```

寫一個函數來取得電影所有的genre資料
```{r}
genresExtract <- function (y) {
  x<- fromJSON(y)
  g <- paste(x$name, collapse="%")
  gsub(" ", "_", g)
}
```

處理第一筆電影的genres資料
```{r}
genresExtract(movies$genres[1])
```

處理所有電影的genres資料
```{r}
movies$genres_data <- sapply(movies$genres, genresExtract)
```

```{r}
movies_genres <- movies %>%
  select(id, genres_data) %>%
  mutate(genres_data=strsplit(genres_data, split="%")) %>%
  unnest(genres_data) %>%
  mutate(value=1)
```

```{r}
movies_genres %>%
  group_by(genres_data) %>%
  summarise(count=sum(value)) %>%
  ggplot() +
  geom_col(aes(x=reorder(genres_data, count), y=count)) +
  coord_flip() +
  scale_y_continuous(limits=c(0, 1800), breaks=seq(0, 1800, 300)) +
  labs(x="類型", y="電影數") +
  theme(panel.background = element_blank(),
        panel.grid.major.x = element_line(color="grey"),
        axis.line =  element_line(color="grey"))
```

少於10部電影的genres
```{r}
movies_genres %>%
  group_by(genres_data) %>%
  summarise(count=sum(value)) %>%
  filter(count<10)
```

刪去Foreign和TV_Movie的資料，然後將movies_genres從long form轉成wide form
```{r}
movies_genres <- movies_genres %>%
  filter(!(genres_data %in% c("Foreign", "TV_Movie"))) %>%
  spread(key=genres_data, value=value, fill=0)
```

理論上來說，兩個data frame 的 Observation數目應當相同。以下找出兩個data frame Observation數目不同的原因。
```{r}
movies$genres[movies$id %in% setdiff(movies$id, movies_genres$id)]
```

刪去genres資料為"[]"的電影，合併兩個data frame，捨棄genres和genres_data兩個variables
```{r}
movies <- movies %>%
  filter(genres!="[]") %>%
  left_join(movies_genres) %>%
  select(-genres, -genres_data)
```

取出電影的keywords，然後捨棄這個variable
```{r}
movies_keywords <- movies %>%
  select(id, keywords)

movies <- movies %>%
  select(-keywords)
```

分析production_companies
```{r}
movies$production_companies[1:5]
```
也是JSON的編碼，所以嘗試以genres用過的方法分析

```{r}
PCExtract <- function(y) {
  x<- fromJSON(y)
  g <- paste(x$name, collapse="%")
  gsub(" ", "_", g)
}

movies$pc_data <- sapply(movies$production_companies, PCExtract)
```

```{r}
movies_pc <- movies %>%
  select(id, pc_data) %>%
  mutate(pc_data=strsplit(pc_data, split="%")) %>%
  unnest(pc_data) %>%
  mutate(value=1)
```

電影製作公司與他們製作的電影數 (按電影數排名)
```{r}
production_companies <- movies_pc %>%
  group_by(pc_data) %>%
  summarise(count=n()) %>%
  arrange(desc(count))
```

製作電影數前100的電影製作公司
```{r}
top100pc <- production_companies$pc_data[1:100]
```

電影的製作公司包含幾家前100製作公司
```{r}
movies_pc <- movies_pc %>%
  mutate(value=ifelse(pc_data %in% top100pc, 1, 0)) %>%
  group_by(id) %>%
  summarise(top_pc_number=sum(value))
```

```{r}
movies <- movies %>%
  left_join(movies_pc) %>%
  mutate(top_pc_number=ifelse(is.na(top_pc_number), 0, top_pc_number)) %>%
  select(-production_companies, -pc_data)
```
